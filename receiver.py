"""
Drone Offboard Control Receiver
===============================

Overview:
---------
This script facilitates real-time reception and handling of drone control packets over UDP,
using MAVSDK to execute offboard control commands on a connected drone. It integrates with
the custom `ControlPacket` class to unpack control directives, and subsequently manages drone
state transitions to ensure smooth operation.

The main focus is to receive commands generated by other sources (e.g., image processing, control systems)
and send them over a network to this script for controlling the drone's flight behavior. These sources can
be on the same device or on a different device in the network. The communication takes place via a UDP port
(`COMMAND_UDP_PORT`).

Features:
---------
- Real-time Packet Reception: Listens on a UDP socket for incoming control packets, enabling external devices
  to send control commands to the drone.
- MAVSDK Integration: Utilizes MAVSDK for comprehensive drone control, including setting initial positions and managing
  various control setpoints like position, velocity, and yaw.
- Robust State Handling: Checks and transitions drone state to ensure offboard control can be safely engaged and disengaged.
- Yaw Management: Supports optional yaw control, setting either a dynamic or static yaw, based on packet instructions. (Only for Local NED Position Command Mode)

Usage:
------
1. Ensure the MAVSDK server is running, and the drone is connected.
2. Run this script on the same network as the MAVSDK server.
3. Send properly formatted control packets to the IP and port specified by `COMMAND_UDP_PORT`.

Command-Line Usage:
-------------------
The following command-line arguments can override global defaults:
- `--connection-type`: Choose the connection method (`serial` or `udp`).
- `--port`: Specify the UDP port number or serial port name (e.g., `/dev/ttyS0` for Raspberry Pi TTL).

Example usage:
    python3 drone_control.py --connection-type udp --port 14550
    python3 drone_control.py --connection-type serial --port '/dev/ttyS0'

Packet Handling:
----------------
The script unpacks received packets using the `ControlPacket` class. It then checks the enable flag within these packets
to either initiate or halt offboard control. If enabled, the script handles the specified control setpoints (position, velocity, yaw, etc.)
and updates the drone's state accordingly.

Testing:
--------
Example graphical user interfaces (GUIs) created with Pygame are available to test and try sending commands to this script.

Author:
-------
Alireza Ghaderi
GitHub: alireza787b
Date: April 2024

Dependencies:
-------------
- MAVSDK-Python
- Python 3.7 or higher

The script's flow is asynchronous to efficiently handle I/O operations. Ensure that the system running this script
has network access to the drone's telemetry and control interface, typically provided by MAVSDK.
"""

import asyncio
import socket
import argparse
import mavsdk
from mavsdk import System
from mavsdk.offboard import *
from control_packet import ControlPacket, SetpointMode

# Global Defaults
DEFAULT_CONNECTION_TYPE = 'udp'
DEFAULT_PORT_UDP = '14540'
DEFAULT_PORT_SERIAL = '/dev/ttyS0'  # Raspberry Pi default TTL

UDP_IP = "0.0.0.0"
COMMAND_UDP_PORT = 5005
BUFFER_SIZE = 1024

def parse_args():
    """Parse command-line arguments to override global connection defaults."""
    parser = argparse.ArgumentParser(description="Drone Offboard Control Receiver")
    parser.add_argument('--connection-type', type=str, choices=['udp', 'serial'], default=None,
                        help='Connection type: udp or serial')
    parser.add_argument('--port', type=str, default=None,
                        help='UDP port number or serial port name (e.g., ttyUSB0 for USB serial)')
    return parser.parse_args()

def construct_connection_string(connection_type, port):
    """Construct the appropriate MAVSDK connection string based on type and port."""
    if connection_type == 'serial':
        return f'serial:///dev/{port}' if not port.startswith('/') else f'serial://{port}'
    return f'udp://:{port}'

def get_connection_parameters():
    """Determine the connection parameters based on global defaults and command-line arguments."""
    args = parse_args()
    connection_type = args.connection_type or DEFAULT_CONNECTION_TYPE
    port = args.port or (DEFAULT_PORT_UDP if connection_type == 'udp' else DEFAULT_PORT_SERIAL)
    return connection_type, construct_connection_string(connection_type, port)

async def setup_drone(connection_string):
    """Initialize and connect to the drone system using the specified connection string."""
    drone = System()
    await drone.connect(system_address=connection_string)

    print("Waiting for drone to connect...")
    async for state in drone.core.connection_state():
        if state.is_connected:
            print("-- Connected to drone!")
            break

    print("Checking global position estimate...")
    async for health in drone.telemetry.health():
        if health.is_global_position_ok:
            print("-- Global position estimate OK")
            break

    return drone


async def handle_packet(drone, packet):
    """
    Unpack and handle an incoming control packet to adjust the drone's behavior.

    This function processes different offboard control modes by interpreting the setpoint flags
    and adjusting the drone's flight accordingly. Supported modes include:
    - VELOCITY_BODY
    - ATTITUDE_CONTROL
    - POSITION_VELOCITY_ACCELERATION_NED
    - POSITION_GLOBAL_LATLON
    - ATTITUDE_RATE_CONTROL
    - ACCELERATION_NED
    - VELOCITY_NED

    Parameters:
    - drone (System): The MAVSDK drone system object.
    - packet (bytes): The incoming control packet in byte form.
    """
    control_packet = ControlPacket.unpack(packet)
    control_packet.debug_print()

    # Engage or disengage offboard control based on the enable flag.
    if control_packet.enable_flag:
        print("Enable flag is true, processing offboard control...")
        is_active = await drone.offboard.is_active()
        current_yaw = 0  # Default yaw initialization

        # Activate offboard mode if it's not already active.
        if not is_active:
            print("Offboard mode is not active, initializing...")
            async for telemetry in drone.telemetry.attitude_euler():
                current_yaw = telemetry.yaw_deg
                break

            async for position in drone.telemetry.position_velocity_ned():
                current_position = position
                break

            print(f"Setting initial position and yaw: North {current_position.position.north_m}, "
                  f"East {current_position.position.east_m}, Down {current_position.position.down_m}, "
                  f"Yaw {current_yaw}")
            await drone.offboard.set_position_ned(
                PositionNedYaw(current_position.position.north_m, current_position.position.east_m,
                               current_position.position.down_m, current_yaw))
            try:
                await drone.offboard.start()
                print("Offboard mode started successfully.")
            except OffboardError as error:
                print(f"Failed to start offboard mode: {error._result.result}")
                return

        # Determine yaw for control modes that require it.
        yaw = control_packet.attitude[2] if control_packet.setpoint_flags & SetpointMode.YAW_CONTROL.value else current_yaw

        # Velocity control in body frame.
        if control_packet.setpoint_flags & SetpointMode.VELOCITY_BODY.value:
            vx = control_packet.velocity[0]
            vy = control_packet.velocity[1]
            vz = control_packet.velocity[2]
            yaw_rate = control_packet.attitude_rate[2]
            await drone.offboard.set_velocity_body(VelocityBodyYawspeed(vx, vy, vz, yaw_rate))
            print(f"Setting VELOCITY_BODY setpoint: Vx={vx}, Vy={vy}, Vz={vz}, Yaw rate={yaw_rate}")

        # Attitude control.
        if control_packet.setpoint_flags & SetpointMode.ATTITUDE_CONTROL.value:
            roll = control_packet.attitude[0]
            pitch = control_packet.attitude[1]
            yaw = control_packet.attitude[2]
            thrust = control_packet.attitude[3]
            print(f"Setting ATTITUDE setpoint: Roll={roll}°, Pitch={pitch}°, Yaw={yaw}°, Thrust={thrust}")
            await drone.offboard.set_attitude(Attitude(roll, pitch, yaw, thrust))

        # Position, velocity, and acceleration control in NED (local) frame.
        if control_packet.setpoint_flags & SetpointMode.POSITION_VELOCITY_ACCELERATION_NED.value:
            position = PositionNedYaw(control_packet.position[0], control_packet.position[1], control_packet.position[2], yaw)
            velocity = VelocityNedYaw(control_packet.velocity[0], control_packet.velocity[1], control_packet.velocity[2], control_packet.attitude_rate[2])
            acceleration = AccelerationNed(control_packet.acceleration[0], control_packet.acceleration[1], control_packet.acceleration[2])
            print(f"Sending POSITION_VELOCITY_ACCELERATION_NED setpoint: Position {position}, Velocity {velocity}, Acceleration {acceleration}")
            await drone.offboard.set_position_velocity_acceleration_ned(position, velocity, acceleration)

        # Global position control using latitude/longitude/altitude.
        if control_packet.setpoint_flags & SetpointMode.POSITION_GLOBAL_LATLON.value:
            lat = control_packet.position[0]
            lon = control_packet.position[1]
            alt = control_packet.position[2]
            yaw = control_packet.attitude[2]
            altitude_type = mavsdk.offboard.AltitudeType.AMSL
            print(f"Sending POSITION_GLOBAL_LATLON setpoint: Latitude {lat}, Longitude {lon}, Altitude {alt}, Yaw {yaw}")
            await drone.offboard.set_position_global(PositionGlobalYaw(lat, lon, alt, yaw, altitude_type))

        # Attitude rate control (roll, pitch, yaw rates, and thrust).
        if control_packet.setpoint_flags & SetpointMode.ATTITUDE_RATE_CONTROL.value:
            roll_deg_s = control_packet.attitude_rate[0]
            pitch_deg_s = control_packet.attitude_rate[1]
            yaw_deg_s = control_packet.attitude_rate[2]
            thrust_value = control_packet.attitude[3]
            print(f"Sending ATTITUDE_RATE_CONTROL setpoint: Roll Rate {roll_deg_s}, Pitch Rate {pitch_deg_s}, Yaw Rate {yaw_deg_s}, Thrust {thrust_value}")
            await drone.offboard.set_attitude_rate(AttitudeRate(roll_deg_s, pitch_deg_s, yaw_deg_s, thrust_value))

        # Acceleration control in NED (local) frame.
        if control_packet.setpoint_flags & SetpointMode.ACCELERATION_NED.value:
            north_acc = control_packet.acceleration[0]
            east_acc = control_packet.acceleration[1]
            down_acc = control_packet.acceleration[2]
            print(f"Setting NED acceleration: North {north_acc} m/s², East {east_acc} m/s², Down {down_acc} m/s²")
            await drone.offboard.set_acceleration_ned(
                AccelerationNed(north_m_s2=north_acc, east_m_s2=east_acc, down_m_s2=down_acc)
            )

        # Velocity control in NED (local) frame.
        if control_packet.setpoint_flags & SetpointMode.VELOCITY_NED.value:
            north_vel = control_packet.velocity[0]
            east_vel = control_packet.velocity[1]
            down_vel = control_packet.velocity[2]
            yaw = control_packet.attitude[2]
            print(f"Setting NED velocity: North {north_vel}, East {east_vel}, Down {down_vel}, Yaw {yaw}")
            await drone.offboard.set_velocity_ned(
                VelocityNedYaw(north_m_s=north_vel, east_m_s=east_vel, down_m_s=down_vel, yaw_deg=yaw)
            )

    # Stop offboard control if the enable flag is false.
    else:
        is_active = await drone.offboard.is_active()
        if is_active:
            print("Enable flag is false, stopping offboard mode...")
            await drone.offboard.stop()


async def receive_packets(drone):
    """Listen for incoming control packets via a UDP socket and process them."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((UDP_IP, COMMAND_UDP_PORT))
    print("UDP socket bound and listening for packets...")

    while True:
        data, _ = sock.recvfrom(BUFFER_SIZE)
        if data:
            await handle_packet(drone, data)

async def main():
    connection_type, connection_string = get_connection_parameters()
    print(f"Connecting via {connection_type}: {connection_string}")
    drone = await setup_drone(connection_string)
    await receive_packets(drone)

if __name__ == "__main__":
    asyncio.run(main())
